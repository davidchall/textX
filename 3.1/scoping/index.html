<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Igor DejanoviÄ‡" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Scoping - textX</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
        <link href="../style.css" rel="stylesheet" />
        <link href="../css/version-select.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Scoping";
        var mkdocs_page_input_path = "scoping.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-68681917-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-68681917-1');
      </script>
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> textX
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">User Guide</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="#">Basics</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../tutorials/hello_world/">Hello world</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../grammar/">Grammar</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../metamodel/">Meta-model</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../model/">Model</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../parser_config/">Parser configuration</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../textx_command/">textx command</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../registration/">Registration/Discovery</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../visualization/">Visualization</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../scaffolding/">Project scaffolding</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../howto/">Howtos</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Scoping and multi-file</a>
    <ul class="current">
                <li class="toctree-l2 current"><a class="reference internal current" href="./">Scoping</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#motivation-and-introduction-to-scoping">Motivation and Introduction to Scoping</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#usage">Usage</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#scope-providers-defined-in-module-textxscopingproviders">Scope Providers defined in Module "textx.scoping.providers"</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#note-on-uniqueness-of-model-elements-global-repository">Note on Uniqueness of Model Elements (global repository)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#included-model-retrieval">Included model retrieval</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#builtin-models">Builtin models</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#technical-aspects-and-implementation-details">Technical aspects and implementation details</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#using-the-scope-provider-to-modify-a-model">Using the scope provider to modify a model</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../rrel/">Reference resolving expression language (RREL)</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../multimetamodel/">Multi meta-model</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">Errors</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../error_handling/">Error handling</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../debugging/">Debugging</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="#">Generators</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../jinja/">Jinja generators</a>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Tutorials</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../tutorials/hello_world/">Hello World</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tutorials/robot/">Robot</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tutorials/entity/">Entity</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tutorials/state_machine/">State Machine</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tutorials/toylanguage/">Toy language compiler</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tutorials/self-dsl/">self-dsl</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tutorials/turtle/">Turtle graphics</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Development</span></p>
              <ul>
                  <li class="toctree-l1"><a class="" href="https://github.com/textX/textX/blob/master/CONTRIBUTING.md">Contributing</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../process/">Release process</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">About</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../about/comparison/">Comparison</a>
                  </li>
                  <li class="toctree-l1"><a class="" href="https://github.com/textX/textX/blob/master/LICENSE.txt">License</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">What's new</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../whatsnew/release_1_5/">Release 1.5</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">textX</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
          <li>User Guide &raquo;</li>
          <li>Scoping and multi-file &raquo;</li>
      <li>Scoping</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/textX/textX/edit/master/docs/scoping.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="textx-scoping">textX Scoping<a class="headerlink" href="#textx-scoping" title="Permanent link">&para;</a></h1>
<h2 id="motivation-and-introduction-to-scoping">Motivation and Introduction to Scoping<a class="headerlink" href="#motivation-and-introduction-to-scoping" title="Permanent link">&para;</a></h2>
<p>Assume a grammar with references as in the following example (grammar snippet).</p>
<pre><code>MyAttribute:
        ref=[MyInterface:FQN] name=ID ';'
;
</code></pre>
<p>The scope provider is responsible for the reference resolution of such a
reference.</p>
<p>The default behavior (default scope provider) is looking for the referenced name
globally (not taking any nested model structures into account, such as nested
model-packages, model-namespaces or similar).</p>
<p>Other scope providers will take namespaces into account, support references to
parts of the model stored in different files or even models defined by other
metamodels (imported into the current metamodel). Moreover, scope providers
exist that allow to reference model elements relative to other referenced model
elements. For example, this can be a referenced method defined in a referenced
class of an instance (with a metamodel defining classes, methods and instances
of classes).</p>
<h2 id="usage">Usage<a class="headerlink" href="#usage" title="Permanent link">&para;</a></h2>
<p>The scope providers are registered with a metamodel and can be bound to specific
attributes of grammar rules:</p>
<ul>
<li>e.g., <code>my_meta_model.register_scope_providers({"*.*": scoping.providers.FQN()})</code>
   bounds <code>FQN</code> provider to all attributes of all grammar rules due to <code>*.*</code></li>
<li>or: <code>my_meta_model.register_scope_providers({"MyAttribute.ref": scoping.providers.FQN()})</code>
   bounds <code>FQN</code> provider to attribute <code>ref</code> of grammar rule <code>MyAttribute</code></li>
<li>or: <code>my_meta_model.register_scope_providers({"*.ref": scoping.providers.FQN()})</code>
   bounds <code>FQN</code> provider to <code>ref</code> attribute of all grammar rules.</li>
<li>or: <code>my_meta_model.register_scope_providers({"MyAttribute.*": scoping.providers.FQN()})</code>
   bounds <code>FQN</code> provider to all attributes of <code>MyAttribute</code> grammar rule</li>
</ul>
<p>Example (from <a href="https://github.com/textX/textX/blob/master/tests/functional/test_scoping/test_local_scope.py">tests/test_scoping/test_local_scope.py</a>):</p>
<pre><code class="language-nohighlight"># Grammar snippet (Components.tx)
Component:
    'component' name=ID ('extends' extends+=[Component:FQN][','])? '{'
        slots*=Slot
    '}'
;
Slot: SlotIn|SlotOut;
# ...
Instance:
    'instance' name=ID ':' component=[Component:FQN] ;
Connection:
    'connect'
      from_inst=[Instance:ID] '.' from_port=[SlotOut:ID]
    'to'
      to_inst=[Instance:ID] '.' to_port=[SlotIn:ID]
;
</code></pre>
<pre><code class="language-python"># Python snippet
my_meta_model = metamodel_from_file(
    os.path.join(abspath(dirname(__file__)), 'components_model1', 'Components.tx')

my_meta_model.register_scope_providers({
    &quot;*.*&quot;: scoping_providers.FQN(),
    &quot;Connection.from_port&quot;: scoping_providers.RelativeName(
        &quot;from_inst.component.slots&quot;),
    &quot;Connection.to_port&quot;: scoping_providers.RelativeName(
        &quot;to_inst.component.slots&quot;),
})
</code></pre>
<p>This example selects the fully qualified name provider as default provider
(<code>"*.*"</code>). Moreover, for special attributes of a <code>Connection</code> a relative name
lookup is specified: here the <code>path</code> from the rule <code>Connection</code> containing the
attribute of interest (e.g. <code>Connection.from_port</code>) to the referenced element is
specified (the slot contained in <code>from_inst.component.slots</code>). Since this
attribute is a list, the list is searched to find the referenced name.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Special rule selections (e.g., <code>Connection.from_port</code>) are preferred
to wildcard selection (e.e, <code>"*.*"</code>).</p>
</div>
<h3 id="scope-providers-defined-in-module-textxscopingproviders">Scope Providers defined in Module "textx.scoping.providers"<a class="headerlink" href="#scope-providers-defined-in-module-textxscopingproviders" title="Permanent link">&para;</a></h3>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The scope provider implementations presented here
assume that the <code>name</code> attribute of named elements
has a string type (e.g. Â´name=IDÂ´).</p>
</div>
<p>We provide some standard scope providers:</p>
<ul>
<li><code>textx.scoping.providers.PlainName</code>: This is the <strong>default provider</strong> of
   textX. It implements global naming within one model (model file/string) 
   without namespaces.</li>
<li>
<p><code>textx.scoping.providers.FQN</code>: This is a <strong>provider similar to Java or Xtext
    name loopup</strong> within one model (model file/string).
    Example: see <a href="https://github.com/textX/textX/blob/master/tests/functional/test_scoping/test_full_qualified_name.py">tests/test_scoping/test_full_qualified_name.py</a>.</p>
<p>A central feature of this scope provider is, that it <strong>traverses the model
tree and searches for a matching sequence of named objects</strong> (objects with
an attribute <code>name</code> matching parts of the full qualified name separated by
dots). You can also provide a <strong>callback</strong> (<code>scope_redirection_logic</code>) to
specify that certain named objects are not searched recursively, but are
replaced by a list of objects instead, which are searched in place of the
current object. With this feature you can create, e.g., <strong>namespace/package
aliases</strong> in your language. You can also activate a <strong>python like module
import behavior</strong> for your language (with
<code>textx.scoping.providers.FQNImportURI</code>), which is based on this callback.
Example: see
<a href="https://github.com/textX/textX/blob/master/tests/functional/regressions/test_issue103_python_like_import.py">tests/functional/regressions/test_issue103_python_like_import.py</a>.</p>
</li>
</ul>
<pre><code class="language-nohighlight">    package p1 {
        package p2 {
            class a {};
        }
    }
    using p1.p2 as main
    var x = new p1.p2.a()
    var y = new main.a()
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Except in the context of the <code>scope_redirection_logic</code> (see above),
the FQN does not take Postponed (unresolved) references into account. The
reason is that this would create a much more complex decision logic to
decide which reference needs to be resolved first. The purpose of the FQN is
to identify direct instances of model objects, and no references.</p>
</div>
<ul>
<li>
<p><code>textx.scoping.providers.ImportURI</code>: This a provider which <strong>allows to load
    additional modules</strong> for lookup.
    You need to define a rule with an attribute <code>importURI</code> as string (like in
    Xtext). This string is then used to load other models. Moreover, you need
    to provide another scope provider to manage the concrete lookup, e.g., the
    <code>scope_provider_plain_names</code> or the <code>scope_provider_fully_qualified_names</code>.
    Model objects formed by the rules with an <code>importURI</code> attribute get an
    additional attribute <code>_tx_loaded_models</code> which is a list of the loaded
    models by this rule instance.
    Example: see <a href="https://github.com/textX/textX/blob/master/tests/functional/test_scoping/test_import_module.py">tests/test_scoping/test_import_module.py</a>.</p>
<ul>
<li><code>FQNImportURI</code> (decorated scope provider)</li>
<li><code>PlainNameImportURI</code> (decorated scope provider)</li>
</ul>
<p>You can use <strong><em>globbing</em></strong> (e.g. <code>import "*.data"</code>) with the ImportURI
feature. This is implemented via the Python <code>glob</code> module. Arguments can be
passed to the <code>glob.glob</code> function (<code>glob_args</code>), e.g., to enable recursive
globbing. Alternatively, you can also specify a list of <strong><em>search
directories</em></strong>. In this case globbing is not allowed and is disabled
(reason: it is unclear if the user wants to glob over all search path
entries or to stop after the first match). Example: see
<a href="https://github.com/textX/textX/blob/master/tests/functional/test_scoping/test_import_module_search_path_issue66.py">tests/test_scoping/test_import_module_search_path_issue66.py</a>.</p>
</li>
<li>
<p><code>textx.scoping.providers.GlobalRepo</code>: This is a provider where <strong>you initially
   need to specifiy the model files to be loaded and used for lookup</strong>. Like
   for <code>ImportURI</code> you need to provide another scope provider for the concrete
   lookup.
   Example: see <a href="https://github.com/textX/textX/blob/master/tests/functional/test_scoping/test_global_import_modules.py">tests/test_scoping/test_global_import_modules.py</a>.</p>
<ul>
<li><code>textx.scoping.providers.FQNGlobalRepo</code> (decorated scope provider)</li>
</ul>
<p>Here, you can also activate the "importAs" feature to allow to make
   imported models not visible in your root namespace, but related to
   a named importURI element (<a href="https://github.com/textX/textX/blob/master/tests/functional/test_scoping/importURI_variations/test_importURI_variations.py">tests/test_scoping/importURI_variations/test_importURI_variations.py</a>)</p>
<p>You can also transform the importURI attribute to a filename:
   see (<a href="https://github.com/textX/textX/blob/master/tests/functional/test_scoping/importURI_variations/test_importURI_variations.py">tests/test_scoping/importURI_variations/test_importURI_variations.py</a>.</p>
<ul>
<li><code>textx.scoping.providers.PlainNameGlobalRepo</code> (decorated scope provider)</li>
</ul>
</li>
<li>
<p><code>textx.scoping.providers.RelativeName</code>: This is a scope provider to <strong>resolve
   relative lookups</strong>: e.g., model-methods of a model-instance, defined by the
   class associated with the model-instance. Typically, another reference (the
   reference to the model-class of a model-instance) is used to determine the
   concrete referenced object (e.g. the model-method, owned by a model-class).
   Example: see <a href="https://github.com/textX/textX/blob/master/tests/functional/test_scoping/test_local_scope.py">tests/test_scoping/test_local_scope.py</a>.</p>
</li>
<li>
<p><code>textx.scoping.providers.ExtRelativeName</code>: The same as <code>RelativeName</code> <strong>allowing
   to model inheritance or chained lookups</strong>.
   Example: see <a href="https://github.com/textX/textX/blob/master/tests/functional/test_scoping/test_local_scope.py">tests/test_scoping/test_local_scope.py</a>.</p>
</li>
</ul>
<h3 id="note-on-uniqueness-of-model-elements-global-repository">Note on Uniqueness of Model Elements (global repository)<a class="headerlink" href="#note-on-uniqueness-of-model-elements-global-repository" title="Permanent link">&para;</a></h3>
<p>Two different models created using one single meta-model (not using a scope
provider like <code>GlobalRepo</code>, but by directly loading the models from file) have
different instances of the same model elements. If you need two such models to
share their model element instances, you can specify this, while creating the
meta model (<code>global_repository=True</code> or
<code>global_repository=instance_of_a_global_repo</code>). Then, the meta model will store
an own instance of a <code>GlobalModelRepository</code> as a base for all loaded models.</p>
<p>Model elements in models including other parts of the model (possibly circular)
have unique model elements (no double instances).</p>
<p>Examples see <a href="https://github.com/textX/textX/blob/master/tests/functional/test_scoping/test_import_module.py">tests/test_scoping/test_import_module.py</a>.</p>
<h3 id="included-model-retrieval">Included model retrieval<a class="headerlink" href="#included-model-retrieval" title="Permanent link">&para;</a></h3>
<p>When a model includes or references other model (model files), the scope 
providers in <code>textx.scoping.providers</code> use the field <code>_tx_model_repository</code>
of the model object to keep track of the included models.</p>
<ul>
<li>You can get a list of all included model objects of a model
   and the model itself with
   <code>textx.scoping.providers.get_all_models_including_attached_models</code>.</li>
<li>You can check if a model file is included by a model with
   <code>textx.scoping.providers.is_file_included_by_model</code>.</li>
</ul>
<h3 id="builtin-models">Builtin models<a class="headerlink" href="#builtin-models" title="Permanent link">&para;</a></h3>
<p>Similarly to <a href="../metamodel/#built-in-objects">builtin objects</a> that are searched
by their names, as a fallback you can provide model repository using
<code>builtin_models</code> parameter during meta-model construction. These models will be
searched by scoping providers based on <code>ImportURI</code> scoping provider after
searching into a local model and all loaded models fails.</p>
<p>This is handy to provide builtin models of the language that are pre-loaded and
don't need to be imported by each user model.</p>
<p>Here is a full example that demonstrates this feature:</p>
<pre><code class="language-python">from textx import metamodel_from_str, metamodel_for_language, register_language
from textx.scoping import ModelRepository

types_mm = metamodel_from_str(r'''
Model: types+=BaseType;
BaseType: 'type' name=ID;
''')

# We register `types` language to be available by `reference` 
# statement in the main meta-model
register_language('types', '*.type', 'Simple types language', types_mm)

# Now in the main meta-model we use `references` to access the
# type language. We also use RREL for `Property.type` (+m:types) to
# specify where instances of `BaseType` can be found.
entity_mm_str = r'''
reference types as t
Model: entities+=Entity;
Entity: 'entity' name=ID '{'
              properties*=Property
        '}'
;
Property: name=ID ':' type=[t.BaseType:ID|+m:types];
'''

# Get `types` language meta-model
types_mm = metamodel_for_language('types')

builtin_models = ModelRepository()

# Construct types model and add it to the repository.
# We instantiate the types model with two BaseType instances: `int` and `bool`
builtin_models.add_model(types_mm.model_from_str('type int type bool'))

# BaseType object `int` and `bool` will now be available to the
# entity meta-model. Standard RREL search mechanism will be used to find the
# referenced model object
entity_mm = metamodel_from_str(entity_mm_str, builtin_models=builtin_models)

# In this model `bool` type is accessible despite not being explicitly imported.
model = entity_mm.model_from_str(r'''
entity First {
    first : bool
}
''')

assert model.entities[0].properties[0].type.name == 'bool'
assert model.entities[0].properties[0].type.__class__.__name__ == 'BaseType'
''')

</code></pre>
<h2 id="technical-aspects-and-implementation-details">Technical aspects and implementation details<a class="headerlink" href="#technical-aspects-and-implementation-details" title="Permanent link">&para;</a></h2>
<p>The scope providers are Python callables accepting <code>obj, attr, obj_ref</code>:</p>
<ul>
<li><code>obj</code>     : the object representing the start of the search (e.g., a rule,
               like<code>MyAttribute</code> in the example above, or the model)</li>
<li><code>attr</code>    : a reference to the attribute (e.g. <code>ref</code> in the first example above)</li>
<li><code>obj_ref</code> : a <code>textx.model.ObjCrossRef</code> - the reference to be resolved</li>
</ul>
<p>The scope provider return the referenced object (e.g. a <code>MyInterface</code> object in
the example illustrated in the <code>Motivation and Introduction</code> above (or <code>None</code> if
nothing is found; or a <code>Postponed</code> object, see below).</p>
<p>The scope provider is responsible to check the type and throw a
<code>TextXSemanticError</code> if the type is not OK.</p>
<p>Scope providers shall be stateless or have unmodifiable state after
construction: this means they should allow to be reused for different models
(created using the same meta-model) without interacting with each other. This
means, they must save their state in the corresponding model, if they need to
store data (e.g., if they load additional models from files <em>during name
resolution</em>, they are not allowed to store them inside the scope provider.</p>
<p>Models with references being resolved have a temporary attribute
<code>_tx_reference_resolver</code> of type <code>ReferenceResolver</code>. This object can be used to
resolve the object. It contains information, such as the parser in charge for
the model (file) being processed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Scope providers as normal functions (<code>def &lt;name&gt;(...):...</code>), not
accessing global data, are safe per se. The reason to be stateless, is that
no side effects (beside, e.g., loading other models) should influence the
name lookup.</p>
</div>
<p>The state of model resolution should mainly consist of models already loaded.
These models are stored in a <code>GlobalModelRepository</code> class. This class (if
required) is stored in the model. An included model loaded from another
including model "inherits" the part of the <code>GlobalModelRepository</code> representing
all loaded models. This is done to (a) cache already loaded models and (b)
guarantee, that every referenced model element is instantiated exactly once.
Even in the case of circular inclusions.</p>
<p>Scope providers may return an object of type <code>Postponed</code>, if they depend on
another event to happen first. This event is typically the resolution of another
reference. The resolution process will repeat multiple times over all unresolved
references to be resolved until all references are resolved or no progress
regarding the resolution is observed. In the latter case an error is raised. The
control flow responsibility of the resolution process is allocated to the
<code>model.py</code> module.</p>
<h3 id="using-the-scope-provider-to-modify-a-model">Using the scope provider to modify a model<a class="headerlink" href="#using-the-scope-provider-to-modify-a-model" title="Permanent link">&para;</a></h3>
<p>Model creation by the metamodel (loading the model) is divided into
a set of strictly ordered activities. Understanding that order
makes it clear where in the metamodel and its configuration (e.g.,
scope providers or object processors) it is allowed to modify the
model itself and what has to be taken into account.</p>
<p>The following image sketches these ordered activities:
<img alt="model_from_file_or_str.pu" src="../images/model_from_file_or_str.png" /></p>
<p>The image illustrates that, while <strong>resolving references</strong>, all directly modeled
objects are already loaded and instantiated. Scoping takes place after the model is completely parsed. Thus, 
while resolving references you can rely on the assumption that all
model elements already exist.</p>
<p>It also shows, that <strong>objects processors</strong> kick in when all 
references are resolved. That means that no references are 
resolved any more after or while the first object processor has been
executed. One <strong>exception</strong> is when calling <strong>object processors for match rules</strong> 
(e.g. regular expressions or rules like 'ID'): these processors are <em>called bottom up</em>
during model construction. Those object processors should generally be a very 
simple, usually just a type conversions so they don't need a fully constructed model. 
<strong>Other object processors</strong> (i.e. those operating on common rules) are called, 
as depicted above, on a constructed model, <em>in bottom up</em> fashion.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>while resolving references,
user classes have modified attr-methods (<code>__setattr__</code>, <code>__getattr__</code>, <code>__delattr__</code>, and <code>__getattribute__</code>)
in order to enable user classes with modified/restricted attribute access,
like classes employing <code>__slots__</code> 
(see <a href="../metamodel/##custom-classes">Custom classes</a>).</p>
</div>
<h4 id="use-case-reference-data-in-non-textx-models">Use case: reference data in non-textx models<a class="headerlink" href="#use-case-reference-data-in-non-textx-models" title="Permanent link">&para;</a></h4>
<p>If you want to <strong>reference an element not directly modelled</strong> (instantiated), you need to
instantiate or load this element or information somewhere. This information can be,
e.g., information from a non-textx model, such as a JSON file 
(see: <a href="https://github.com/textX/textX/blob/master/tests/functional/test_scoping/test_reference_to_nontextx_attribute.py">test_reference_to_nontextx_attribute.py</a>).
Since you need to resolve a reference (e.g. to an <code>[OBJECT]</code> in the
given example), you cannot rely on object processors, since they are executed
<em>after</em> reference resolution. Thus, scope providers need to take care of
that (e.g., take care of loading the JSON data).</p>
<h4 id="use-case-reference-data-defined-by-references">Use case: reference data "defined by references"<a class="headerlink" href="#use-case-reference-data-defined-by-references" title="Permanent link">&para;</a></h4>
<p>You may have the use case, that you want to
define/instantiate objects by referencing them (on the fly).
This may happen, if your meta model allows to define a model element by referencing
it (like <a href="http://plantuml.com/">PlantUML</a> is doing for, e.g., classes).
In that case <strong>your scope provider creates (invents) model elements</strong>. </p>
<p>If you then require to reference these model elements "defined by
a reference" by another "non-inventing reference", 
you must take into account that these elements
may have not yet been created. This can be achieved in the same 
way as handling unresolved references in a scope provider (with the 
<code>Postponed</code> mechanism). This use case was motivated by 
<a href="https://github.com/textX/textX/issues/167">#167</a>.</p>
<p>An example of such a meta model is given in 
<a href="https://github.com/textX/textX/blob/master/tests/functional/test_scoping/test_model_modification_through_scoping.py">tests/test_model_modification_through_scoping.py</a>:
Here you can </p>
<ul>
<li><strong>define</strong> Persons explicitly (existence) and</li>
<li><strong>reference</strong> two persons which <strong>know</strong> each other (relationship). 
 Moreover, <strong>referencing a nonexistent persons</strong> (all person explicitly defined
 by the grammar have been created at the time of reference resolving)
 will <strong>create an additional (new) person</strong> (and, thus, modify the model).</li>
</ul>
<p>In an extension of the grammar we then also allow </p>
<ul>
<li>to <strong>greet</strong> persons. This also happens by referencing a person (like for
 the "knows"-relationship). 
 But this time, <strong>nonexistent persons shall not be created</strong>, but should yield 
 a referencing error. </li>
</ul>
<p><strong>Implementation:</strong> Since it is unclear if a
 nonexistent person may be created by a not yet resolved "knows"-relationship reference, 
 we have to postpone the resolution of a failed greeting (return <code>Postponed</code>). 
 The reference resolution mechanism will detect if a state is reached 
 with only postponed references and will then raise an error, as expected.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../howto/" class="btn btn-neutral float-left" title="Howtos"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../rrel/" class="btn btn-neutral float-right" title="Reference resolving expression language (RREL)">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
      <p>Copyright &copy; <a href="http://www.igordejanovic.net/">Igor DejanoviÄ‡</a>.</p>
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/textX/textX" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../howto/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../rrel/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
      <script src="../js/version-select.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
